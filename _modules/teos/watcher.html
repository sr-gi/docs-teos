

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>teos.watcher &mdash; pyton-teos  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> pyton-teos
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../teos.html">teos package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../common.html">common package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contrib.html">contrib package</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyton-teos</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>teos.watcher</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for teos.watcher</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">readerwriterlock</span> <span class="kn">import</span> <span class="n">rwlock</span>

<span class="kn">from</span> <span class="nn">teos.logger</span> <span class="kn">import</span> <span class="n">get_logger</span>
<span class="kn">import</span> <span class="nn">common.receipts</span> <span class="k">as</span> <span class="nn">receipts</span>
<span class="kn">from</span> <span class="nn">common.tools</span> <span class="kn">import</span> <span class="n">compute_locator</span>
<span class="kn">from</span> <span class="nn">common.exceptions</span> <span class="kn">import</span> <span class="n">BasicException</span>
<span class="kn">from</span> <span class="nn">common.exceptions</span> <span class="kn">import</span> <span class="n">EncryptionError</span>
<span class="kn">from</span> <span class="nn">common.cryptographer</span> <span class="kn">import</span> <span class="n">Cryptographer</span><span class="p">,</span> <span class="n">hash_160</span>
<span class="kn">from</span> <span class="nn">common.exceptions</span> <span class="kn">import</span> <span class="n">InvalidParameter</span><span class="p">,</span> <span class="n">SignatureError</span>

<span class="kn">from</span> <span class="nn">teos.cleaner</span> <span class="kn">import</span> <span class="n">Cleaner</span>
<span class="kn">from</span> <span class="nn">teos.extended_appointment</span> <span class="kn">import</span> <span class="n">ExtendedAppointment</span>
<span class="kn">from</span> <span class="nn">teos.block_processor</span> <span class="kn">import</span> <span class="n">InvalidTransactionFormat</span>


<div class="viewcode-block" id="AppointmentLimitReached"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.AppointmentLimitReached">[docs]</a><span class="k">class</span> <span class="nc">AppointmentLimitReached</span><span class="p">(</span><span class="n">BasicException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised when the tower maximum appointment count has been reached.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="AppointmentAlreadyTriggered"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.AppointmentAlreadyTriggered">[docs]</a><span class="k">class</span> <span class="nc">AppointmentAlreadyTriggered</span><span class="p">(</span><span class="n">BasicException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raised when an appointment is sent to the Watcher but that same data has already been sent to the :obj:`Responder`.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="AppointmentNotFound"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.AppointmentNotFound">[docs]</a><span class="k">class</span> <span class="nc">AppointmentNotFound</span><span class="p">(</span><span class="n">BasicException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised when an appointment is not found on the tower.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="LocatorCache"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.LocatorCache">[docs]</a><span class="k">class</span> <span class="nc">LocatorCache</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :obj:`LocatorCache` keeps the data about the last ``cache_size`` blocks around so appointments can be checked</span>
<span class="sd">    against it. The data is indexed by locator and it&#39;s mainly built during the normal :obj:`Watcher` operation so no</span>
<span class="sd">    extra steps are normally needed.</span>

<span class="sd">    Args:</span>
<span class="sd">        blocks_in_cache (:obj:`int`): the numbers of blocks to keep in the cache.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        logger (:obj:`Logger &lt;teos.logger.Logger&gt;`): The logger for this component.</span>
<span class="sd">        cache (:obj:`dict`): A dictionary of ``locator:dispute_txid`` pairs that received appointments are checked</span>
<span class="sd">            against.</span>
<span class="sd">        blocks (:obj:`OrderedDict`): An ordered dictionary of the last ``blocks_in_cache`` blocks</span>
<span class="sd">            (``block_hash:locators``). Used to keep track of what data belongs to what block, so data can be pruned</span>
<span class="sd">            accordingly. Also needed to rebuild the cache in case of reorgs.</span>
<span class="sd">        cache_size (:obj:`int`): The size of the cache in blocks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocks_in_cache</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">LocatorCache</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_size</span> <span class="o">=</span> <span class="n">blocks_in_cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rw_lock</span> <span class="o">=</span> <span class="n">rwlock</span><span class="o">.</span><span class="n">RWLockWrite</span><span class="p">()</span>

<div class="viewcode-block" id="LocatorCache.init"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.LocatorCache.init">[docs]</a>    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">last_known_block</span><span class="p">,</span> <span class="n">block_processor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the initial state of the locator cache.</span>

<span class="sd">        Args:</span>
<span class="sd">            last_known_block (:obj:`str`): the last known block by the :obj:`Watcher`.</span>
<span class="sd">            block_processor (:obj:`BlockProcessor &lt;teos.block_processor.BlockProcessor&gt;`): a block processor instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This is needed as a separate method from __init__ since it has to be initialized right before start watching.</span>
        <span class="c1"># Not doing so implies store temporary variables in the Watcher and initialising the cache as None.</span>
        <span class="n">target_block_hash</span> <span class="o">=</span> <span class="n">last_known_block</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_size</span><span class="p">):</span>
            <span class="c1"># In some setups, like regtest, it could be the case that there are no enough previous blocks.</span>
            <span class="c1"># In those cases we pull as many as we can (up to cache_size).</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">target_block_hash</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">target_block</span> <span class="o">=</span> <span class="n">block_processor</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">target_block_hash</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">target_block</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">locator_txid_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">compute_locator</span><span class="p">(</span><span class="n">txid</span><span class="p">):</span> <span class="n">txid</span> <span class="k">for</span> <span class="n">txid</span> <span class="ow">in</span> <span class="n">target_block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tx&quot;</span><span class="p">)}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">locator_txid_map</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">target_block_hash</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">locator_txid_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">target_block_hash</span> <span class="o">=</span> <span class="n">target_block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;previousblockhash&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">reversed</span><span class="p">((</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">items</span><span class="p">()))))</span></div>

<div class="viewcode-block" id="LocatorCache.get_txid"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.LocatorCache.get_txid">[docs]</a>    <span class="k">def</span> <span class="nf">get_txid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets a txid from the locator cache.</span>

<span class="sd">        Args:</span>
<span class="sd">            locator (:obj:`str`): the locator to lookup in the cache.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`str` or :obj:`None`: The txid linked to the given locator if found. None otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">rw_lock</span><span class="o">.</span><span class="n">gen_rlock</span><span class="p">():</span>
            <span class="n">locator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">locator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">locator</span></div>

<div class="viewcode-block" id="LocatorCache.update"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.LocatorCache.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_hash</span><span class="p">,</span> <span class="n">locator_txid_map</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the cache with data from a new block. Removes the oldest block if the cache is full after the addition.</span>

<span class="sd">        Args:</span>
<span class="sd">            block_hash (:obj:`str`): the hash of the new block.</span>
<span class="sd">            locator_txid_map (:obj:`dict`): the dictionary of locators (locator:txid) derived from a list of transaction</span>
<span class="sd">                ids.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">rw_lock</span><span class="o">.</span><span class="n">gen_wlock</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">locator_txid_map</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">block_hash</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">locator_txid_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Block added to cache&quot;</span><span class="p">,</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_full</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_oldest_block</span><span class="p">()</span></div>

<div class="viewcode-block" id="LocatorCache.is_full"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.LocatorCache.is_full">[docs]</a>    <span class="k">def</span> <span class="nf">is_full</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  Returns whether the cache is full or not.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">rw_lock</span><span class="o">.</span><span class="n">gen_rlock</span><span class="p">():</span>
            <span class="n">full</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_size</span>
        <span class="k">return</span> <span class="n">full</span></div>

<div class="viewcode-block" id="LocatorCache.remove_oldest_block"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.LocatorCache.remove_oldest_block">[docs]</a>    <span class="k">def</span> <span class="nf">remove_oldest_block</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Removes the oldest block from the cache.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">rw_lock</span><span class="o">.</span><span class="n">gen_wlock</span><span class="p">():</span>
            <span class="n">block_hash</span><span class="p">,</span> <span class="n">locators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">locator</span> <span class="ow">in</span> <span class="n">locators</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">locator</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Block removed from cache&quot;</span><span class="p">,</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">)</span></div>

<div class="viewcode-block" id="LocatorCache.fix"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.LocatorCache.fix">[docs]</a>    <span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">last_known_block</span><span class="p">,</span> <span class="n">block_processor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fixes the cache after a reorg has been detected by feeding the most recent ``cache_size`` blocks to it.</span>

<span class="sd">        Args:</span>
<span class="sd">            last_known_block (:obj:`str`): the last known block hash after the reorg.</span>
<span class="sd">            block_processor (:obj:`BlockProcessor &lt;teos.block_processor.BlockProcessor&gt;`): a block processor instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tmp_cache</span> <span class="o">=</span> <span class="n">LocatorCache</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_size</span><span class="p">)</span>

        <span class="c1"># We assume there are no reorgs back to genesis. If so, this would raise some log warnings. And the cache will</span>
        <span class="c1"># be filled with less than cache_size blocks.</span>
        <span class="n">target_block_hash</span> <span class="o">=</span> <span class="n">last_known_block</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp_cache</span><span class="o">.</span><span class="n">cache_size</span><span class="p">):</span>
            <span class="n">target_block</span> <span class="o">=</span> <span class="n">block_processor</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">target_block_hash</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">target_block</span><span class="p">:</span>
                <span class="c1"># Compute the locator:txid pair for every transaction in the block and update both the cache and</span>
                <span class="c1"># the block mapping.</span>
                <span class="n">locator_txid_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">compute_locator</span><span class="p">(</span><span class="n">txid</span><span class="p">):</span> <span class="n">txid</span> <span class="k">for</span> <span class="n">txid</span> <span class="ow">in</span> <span class="n">target_block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tx&quot;</span><span class="p">)}</span>
                <span class="n">tmp_cache</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">locator_txid_map</span><span class="p">)</span>
                <span class="n">tmp_cache</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">target_block_hash</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">locator_txid_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">target_block_hash</span> <span class="o">=</span> <span class="n">target_block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;previousblockhash&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">rw_lock</span><span class="o">.</span><span class="n">gen_wlock</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">reversed</span><span class="p">((</span><span class="nb">list</span><span class="p">(</span><span class="n">tmp_cache</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">items</span><span class="p">()))))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">tmp_cache</span><span class="o">.</span><span class="n">cache</span></div></div>


<div class="viewcode-block" id="Watcher"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher">[docs]</a><span class="k">class</span> <span class="nc">Watcher</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`Watcher` is in charge of watching for channel breaches for the appointments accepted by the tower.</span>

<span class="sd">    The :class:`Watcher` keeps track of the accepted appointments in ``appointments`` and, for new received blocks,</span>
<span class="sd">    checks if any breach has happened by comparing the txids with the appointment locators. If a breach is seen, the</span>
<span class="sd">    ``encrypted_blob`` of the corresponding appointment is decrypted and the data is passed to the</span>
<span class="sd">    :obj:`Responder &lt;teos.responder.Responder&gt;`.</span>

<span class="sd">    If an appointment reaches its end with no breach, the data is simply deleted.</span>

<span class="sd">    The :class:`Watcher` receives information about new received blocks via the ``block_queue`` that is populated by the</span>
<span class="sd">    :obj:`ChainMonitor &lt;teos.chain_monitor.ChainMonitor&gt;`.</span>

<span class="sd">    Args:</span>
<span class="sd">        db_manager (:obj:`AppointmentsDBM &lt;teos.appointments_dbm.AppointmentsDBM&gt;`): an instance of the appointment</span>
<span class="sd">                database manager to interact with the database.</span>
<span class="sd">        block_processor (:obj:`BlockProcessor &lt;teos.block_processor.BlockProcessor&gt;`): a block processor instance to</span>
<span class="sd">            get block from bitcoind.</span>
<span class="sd">        responder (:obj:`Responder &lt;teos.responder.Responder&gt;`): a responder instance.</span>
<span class="sd">        sk (:obj:`PrivateKey`): a private key used to sign accepted appointments.</span>
<span class="sd">        max_appointments (:obj:`int`): the maximum amount of appointments accepted by the :obj:`Watcher` at the same</span>
<span class="sd">            time.</span>
<span class="sd">        blocks_in_cache (:obj:`int`): the number of blocks to keep in cache so recently triggered appointments can be</span>
<span class="sd">            covered.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        appointments (:obj:`dict`): A dictionary containing a summary of the appointments (:obj:`ExtendedAppointment</span>
<span class="sd">            &lt;teos.extended_appointment.ExtendedAppointment&gt;` instances) accepted by the tower (``locator`` and</span>
<span class="sd">            ``user_id``). It&#39;s populated trough ``add_appointment``.</span>
<span class="sd">        locator_uuid_map (:obj:`dict`): A ``locator:uuid`` map used to allow the :obj:`Watcher` to deal with several</span>
<span class="sd">            appointments with the same ``locator``.</span>
<span class="sd">        block_queue (:obj:`Queue`): A queue used by the :obj:`Watcher` to receive block hashes from ``bitcoind``. It is</span>
<span class="sd">            populated by the :obj:`ChainMonitor &lt;teos.chain_monitor.ChainMonitor&gt;`.</span>
<span class="sd">        db_manager (:obj:`AppointmentsDBM &lt;teos.appointments_dbm.AppointmentsDBM&gt;`): An instance of the appointment</span>
<span class="sd">                database manager to interact with the database.</span>
<span class="sd">        gatekeeper (:obj:`Gatekeeper &lt;teos.gatekeeper.Gatekeeper&gt;`): A gatekeeper instance in charge to control the</span>
<span class="sd">            user access and subscription expiry.</span>
<span class="sd">        block_processor (:obj:`BlockProcessor &lt;teos.block_processor.BlockProcessor&gt;`): A block processor instance to</span>
<span class="sd">            get block from bitcoind.</span>
<span class="sd">        responder (:obj:`Responder &lt;teos.responder.Responder&gt;`): A responder instance.</span>
<span class="sd">        signing_key (:obj:`PrivateKey`): A private key used to sign accepted appointments.</span>
<span class="sd">        max_appointments (:obj:`int`): The maximum amount of appointments accepted by the :obj:`Watcher` at the same</span>
<span class="sd">            time.</span>
<span class="sd">        last_known_block (:obj:`str`): The last block known by the :obj:`Watcher`.</span>
<span class="sd">        locator_cache (:obj:`LocatorCache`): A cache of locators for the last ``blocks_in_cache`` blocks.</span>

<span class="sd">    Raises:</span>
<span class="sd">        :obj:`InvalidKey`: if teos sk cannot be loaded.\</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_manager</span><span class="p">,</span> <span class="n">gatekeeper</span><span class="p">,</span> <span class="n">block_processor</span><span class="p">,</span> <span class="n">responder</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">max_appointments</span><span class="p">,</span> <span class="n">blocks_in_cache</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="n">component</span><span class="o">=</span><span class="n">Watcher</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">appointments</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locator_uuid_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span> <span class="o">=</span> <span class="n">db_manager</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gatekeeper</span> <span class="o">=</span> <span class="n">gatekeeper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_processor</span> <span class="o">=</span> <span class="n">block_processor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">responder</span> <span class="o">=</span> <span class="n">responder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_appointments</span> <span class="o">=</span> <span class="n">max_appointments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signing_key</span> <span class="o">=</span> <span class="n">sk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_known_block</span> <span class="o">=</span> <span class="n">db_manager</span><span class="o">.</span><span class="n">load_last_block_hash_watcher</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locator_cache</span> <span class="o">=</span> <span class="n">LocatorCache</span><span class="p">(</span><span class="n">blocks_in_cache</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tower_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the id of this tower, as a hex string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Cryptographer</span><span class="o">.</span><span class="n">get_compressed_pk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signing_key</span><span class="o">.</span><span class="n">public_key</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_registered_users</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the number of users currently registered to the tower.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gatekeeper</span><span class="o">.</span><span class="n">registered_users</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_watcher_appointments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the total number of appointments stored in the watcher.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_responder_trackers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the total number of trackers in the responder.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">responder</span><span class="o">.</span><span class="n">trackers</span><span class="p">)</span>

<div class="viewcode-block" id="Watcher.awake"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher.awake">[docs]</a>    <span class="k">def</span> <span class="nf">awake</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Starts a new thread to monitor the blockchain for channel breaches. The thread will run until the</span>
<span class="sd">            :obj:`ChainMonitor` adds the ``&quot;END&quot;`` message to the queue.</span>

<span class="sd">            Returns:</span>
<span class="sd">                :obj:`Thread &lt;multithreading.Thread&gt;`: The thread object that was just created and is already running.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">watcher_thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">do_watch</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">watcher_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">watcher_thread</span></div>

<div class="viewcode-block" id="Watcher.register"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a user.</span>

<span class="sd">        Args:</span>
<span class="sd">            user_id (:obj:`str`): the public key that identifies the user (33-bytes hex str).</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`tuple`: A tuple containing the available slots, the subscription expiry, and the signature of the</span>
<span class="sd">            registration receipt by the Watcher.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">available_slots</span><span class="p">,</span> <span class="n">subscription_expiry</span><span class="p">,</span> <span class="n">registration_receipt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gatekeeper</span><span class="o">.</span><span class="n">add_update_user</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
        <span class="n">signature</span> <span class="o">=</span> <span class="n">Cryptographer</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">registration_receipt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">signing_key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">available_slots</span><span class="p">,</span> <span class="n">subscription_expiry</span><span class="p">,</span> <span class="n">signature</span></div>

<div class="viewcode-block" id="Watcher.get_appointment"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher.get_appointment">[docs]</a>    <span class="k">def</span> <span class="nf">get_appointment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">,</span> <span class="n">user_signature</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets information about an appointment.</span>

<span class="sd">        The appointment can either be in the watcher, the responder, or not found.</span>

<span class="sd">        Args:</span>
<span class="sd">            locator (:obj:`str`): a 16-byte hex-encoded value used by the tower to detect channel breaches.</span>
<span class="sd">            user_signature (:obj:`str`): the signature of the request by the user.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`tuple`: A tuple containing the appointment data and the status (either ``&quot;being_watched&quot;`` or</span>
<span class="sd">            ``&quot;dispute_responded&quot;``).</span>

<span class="sd">        Raises:</span>
<span class="sd">            :obj:`AppointmentNotFound`: if the appointment is not found in the tower.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;get appointment </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">locator</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
        <span class="n">user_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gatekeeper</span><span class="o">.</span><span class="n">authenticate_user</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">user_signature</span><span class="p">)</span>
        <span class="n">uuid</span> <span class="o">=</span> <span class="n">hash_160</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">locator</span><span class="p">,</span> <span class="n">user_id</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">uuid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="p">:</span>
            <span class="n">appointment_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">load_watcher_appointment</span><span class="p">(</span><span class="n">uuid</span><span class="p">)</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;being_watched&quot;</span>
        <span class="k">elif</span> <span class="n">uuid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">responder</span><span class="o">.</span><span class="n">trackers</span><span class="p">:</span>
            <span class="n">appointment_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">load_responder_tracker</span><span class="p">(</span><span class="n">uuid</span><span class="p">)</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;dispute_responded&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AppointmentNotFound</span><span class="p">(</span><span class="s2">&quot;Cannot find </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">locator</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">appointment_data</span><span class="p">,</span> <span class="n">status</span></div>

<div class="viewcode-block" id="Watcher.add_appointment"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher.add_appointment">[docs]</a>    <span class="k">def</span> <span class="nf">add_appointment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">appointment</span><span class="p">,</span> <span class="n">user_signature</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new appointment to the ``appointments`` dictionary if ``max_appointments`` has not been reached.</span>

<span class="sd">        ``add_appointment`` is the entry point of the :obj:`Watcher`. Upon receiving a new appointment it will start</span>
<span class="sd">        monitoring the blockchain (``do_watch``) until ``appointments`` is empty.</span>

<span class="sd">        Once a breach is seen on the blockchain, the :obj:`Watcher` will decrypt the corresponding ``encrypted_blob``</span>
<span class="sd">        and pass the information to the :obj:`Responder &lt;teos.responder.Responder&gt;`.</span>

<span class="sd">        The tower may store multiple appointments with the same ``locator`` to avoid DoS attacks based on data</span>
<span class="sd">        rewriting. `locators`` should be derived from the ``dispute_txid``, but that task is performed by the user, and</span>
<span class="sd">        the tower has no way of verifying whether or not they have been properly derived. Therefore, appointments are</span>
<span class="sd">        identified by ``uuid`` and stored in ``appointments`` and ``locator_uuid_map``.</span>

<span class="sd">        Args:</span>
<span class="sd">            appointment (:obj:`Appointment &lt;common.appointment.Appointment&gt;`): the appointment to be added to the</span>
<span class="sd">                :obj:`Watcher`.</span>
<span class="sd">            user_signature (:obj:`str`): the user&#39;s appointment signature (hex-encoded).</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`dict`: The tower response as a dict, containing: ``locator``, ``signature``, ``available_slots`` and</span>
<span class="sd">            ``subscription_expiry``.</span>

<span class="sd">        Raises:</span>
<span class="sd">            :obj:`AppointmentLimitReached`: If the tower cannot hold more appointments (cap reached).</span>
<span class="sd">            :obj:`AuthenticationFailure`: If the user cannot be authenticated.</span>
<span class="sd">            :obj:`NotEnoughSlots`: If the user does not have enough available slots, so the appointment is rejected.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_appointments</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Maximum appointments reached, appointment rejected&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">locator</span><span class="o">=</span><span class="n">appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">AppointmentLimitReached</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="n">user_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gatekeeper</span><span class="o">.</span><span class="n">authenticate_user</span><span class="p">(</span><span class="n">appointment</span><span class="o">.</span><span class="n">serialize</span><span class="p">(),</span> <span class="n">user_signature</span><span class="p">)</span>
        <span class="n">start_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_processor</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_known_block</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;height&quot;</span><span class="p">)</span>
        <span class="n">extended_appointment</span> <span class="o">=</span> <span class="n">ExtendedAppointment</span><span class="p">(</span>
            <span class="n">appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">,</span>
            <span class="n">appointment</span><span class="o">.</span><span class="n">encrypted_blob</span><span class="p">,</span>
            <span class="n">appointment</span><span class="o">.</span><span class="n">to_self_delay</span><span class="p">,</span>
            <span class="n">user_id</span><span class="p">,</span>
            <span class="n">user_signature</span><span class="p">,</span>
            <span class="n">start_block</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># The uuids are generated as the RIPEMD160(locator||user_pubkey).</span>
        <span class="c1"># If an appointment is requested by the user the uuid can be recomputed and queried straightaway (no maps).</span>
        <span class="n">uuid</span> <span class="o">=</span> <span class="n">hash_160</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extended_appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">,</span> <span class="n">user_id</span><span class="p">))</span>

        <span class="c1"># If this is a copy of an appointment we&#39;ve already reacted to, the new appointment is rejected.</span>
        <span class="k">if</span> <span class="n">uuid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">responder</span><span class="o">.</span><span class="n">trackers</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Appointment already in Responder&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">AppointmentAlreadyTriggered</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="c1"># Add the appointment to the Gatekeeper</span>
        <span class="n">available_slots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gatekeeper</span><span class="o">.</span><span class="n">add_update_appointment</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">uuid</span><span class="p">,</span> <span class="n">extended_appointment</span><span class="p">)</span>

        <span class="c1"># Appointments that were triggered in blocks held in the cache</span>
        <span class="n">dispute_txid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator_cache</span><span class="o">.</span><span class="n">get_txid</span><span class="p">(</span><span class="n">extended_appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dispute_txid</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">penalty_txid</span><span class="p">,</span> <span class="n">penalty_rawtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_breach</span><span class="p">(</span><span class="n">uuid</span><span class="p">,</span> <span class="n">extended_appointment</span><span class="p">,</span> <span class="n">dispute_txid</span><span class="p">)</span>
                <span class="n">receipt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">responder</span><span class="o">.</span><span class="n">handle_breach</span><span class="p">(</span>
                    <span class="n">uuid</span><span class="p">,</span>
                    <span class="n">extended_appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">,</span>
                    <span class="n">dispute_txid</span><span class="p">,</span>
                    <span class="n">penalty_txid</span><span class="p">,</span>
                    <span class="n">penalty_rawtx</span><span class="p">,</span>
                    <span class="n">user_id</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">last_known_block</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># At this point the appointment is accepted but data is only kept if it goes through the Responder.</span>
                <span class="c1"># Otherwise it is dropped.</span>
                <span class="k">if</span> <span class="n">receipt</span><span class="o">.</span><span class="n">delivered</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">store_watcher_appointment</span><span class="p">(</span><span class="n">uuid</span><span class="p">,</span> <span class="n">extended_appointment</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">create_append_locator_map</span><span class="p">(</span><span class="n">extended_appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">,</span> <span class="n">uuid</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">create_triggered_appointment_flag</span><span class="p">(</span><span class="n">uuid</span><span class="p">)</span>

            <span class="k">except</span> <span class="p">(</span><span class="n">EncryptionError</span><span class="p">,</span> <span class="n">InvalidTransactionFormat</span><span class="p">):</span>
                <span class="c1"># If data inside the encrypted blob is invalid, the appointment is accepted but the data is dropped.</span>
                <span class="c1"># (same as with data that bounces in the Responder). This reduces the appointment slot count so it</span>
                <span class="c1"># could be used to discourage user misbehaviour.</span>
                <span class="k">pass</span>

        <span class="c1"># Regular appointments that have not been triggered (or, at least, not recently)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="p">[</span><span class="n">uuid</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended_appointment</span><span class="o">.</span><span class="n">get_summary</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">extended_appointment</span><span class="o">.</span><span class="n">locator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator_uuid_map</span><span class="p">:</span>
                <span class="c1"># If the uuid is already in the map it means this is an update.</span>
                <span class="k">if</span> <span class="n">uuid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator_uuid_map</span><span class="p">[</span><span class="n">extended_appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">locator_uuid_map</span><span class="p">[</span><span class="n">extended_appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uuid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise two users have sent an appointment with the same locator, so we need to store both.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">locator_uuid_map</span><span class="p">[</span><span class="n">extended_appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">uuid</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">store_watcher_appointment</span><span class="p">(</span><span class="n">uuid</span><span class="p">,</span> <span class="n">extended_appointment</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">create_append_locator_map</span><span class="p">(</span><span class="n">extended_appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">,</span> <span class="n">uuid</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="n">Cryptographer</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span>
                <span class="n">receipts</span><span class="o">.</span><span class="n">create_appointment_receipt</span><span class="p">(</span><span class="n">user_signature</span><span class="p">,</span> <span class="n">start_block</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">signing_key</span>
            <span class="p">)</span>

        <span class="k">except</span> <span class="p">(</span><span class="n">InvalidParameter</span><span class="p">,</span> <span class="n">SignatureError</span><span class="p">):</span>
            <span class="c1"># This should never happen since data is sanitized, just in case to avoid a crash</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Data couldn&#39;t be signed&quot;</span><span class="p">,</span> <span class="n">appointment</span><span class="o">=</span><span class="n">extended_appointment</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
            <span class="n">signature</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;New appointment accepted&quot;</span><span class="p">,</span> <span class="n">locator</span><span class="o">=</span><span class="n">extended_appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;locator&quot;</span><span class="p">:</span> <span class="n">extended_appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">,</span>
            <span class="s2">&quot;start_block&quot;</span><span class="p">:</span> <span class="n">extended_appointment</span><span class="o">.</span><span class="n">start_block</span><span class="p">,</span>
            <span class="s2">&quot;signature&quot;</span><span class="p">:</span> <span class="n">signature</span><span class="p">,</span>
            <span class="s2">&quot;available_slots&quot;</span><span class="p">:</span> <span class="n">available_slots</span><span class="p">,</span>
            <span class="s2">&quot;subscription_expiry&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gatekeeper</span><span class="o">.</span><span class="n">registered_users</span><span class="p">[</span><span class="n">user_id</span><span class="p">]</span><span class="o">.</span><span class="n">subscription_expiry</span><span class="p">,</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="Watcher.do_watch"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher.do_watch">[docs]</a>    <span class="k">def</span> <span class="nf">do_watch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Monitors the blockchain for channel breaches.</span>

<span class="sd">        This is the main method of the :obj:`Watcher` and the one in charge to pass appointments to the</span>
<span class="sd">        :obj:`Responder &lt;teos.responder.Responder&gt;` upon detecting a breach.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Distinguish fresh bootstraps from bootstraps from db</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_known_block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_known_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_processor</span><span class="o">.</span><span class="n">get_best_block_hash</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">store_last_block_hash_watcher</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_known_block</span><span class="p">)</span>

        <span class="c1"># Initialise the locator cache with the last ``cache_size`` blocks.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locator_cache</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_known_block</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_processor</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">block_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

            <span class="c1"># When the ChainMonitor is stopped, a final &quot;END&quot; message is sent</span>
            <span class="k">if</span> <span class="n">block_hash</span> <span class="o">==</span> <span class="s2">&quot;END&quot;</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_processor</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">block_hash</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;New block received&quot;</span><span class="p">,</span> <span class="n">block_hash</span><span class="o">=</span><span class="n">block_hash</span><span class="p">,</span> <span class="n">prev_block_hash</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;previousblockhash&quot;</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># If a reorg is detected, the cache is fixed to cover the last `cache_size` blocks of the new chain</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_known_block</span> <span class="o">!=</span> <span class="n">block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;previousblockhash&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">locator_cache</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="n">block_hash</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_processor</span><span class="p">)</span>

            <span class="n">txids</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tx&quot;</span><span class="p">)</span>
            <span class="c1"># Compute the locator for every transaction in the block and add them to the cache</span>
            <span class="n">locator_txid_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">compute_locator</span><span class="p">(</span><span class="n">txid</span><span class="p">):</span> <span class="n">txid</span> <span class="k">for</span> <span class="n">txid</span> <span class="ow">in</span> <span class="n">txids</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">locator_cache</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">block_hash</span><span class="p">,</span> <span class="n">locator_txid_map</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">locator_txid_map</span><span class="p">:</span>
                <span class="n">expired_appointments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gatekeeper</span><span class="o">.</span><span class="n">get_expired_appointments</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">])</span>
                <span class="c1"># Make sure we only try to delete what is on the Watcher (some appointments may have been triggered)</span>
                <span class="n">expired_appointments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">expired_appointments</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

                <span class="c1"># Keep track of the expired appointments before deleting them from memory</span>
                <span class="n">appointments_to_delete_gatekeeper</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">uuid</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="p">[</span><span class="n">uuid</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;user_id&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">uuid</span> <span class="ow">in</span> <span class="n">expired_appointments</span>
                <span class="p">}</span>

                <span class="n">Cleaner</span><span class="o">.</span><span class="n">delete_expired_appointments</span><span class="p">(</span>
                    <span class="n">expired_appointments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator_uuid_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span>
                <span class="p">)</span>

                <span class="n">valid_breaches</span><span class="p">,</span> <span class="n">invalid_breaches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_breaches</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_breaches</span><span class="p">(</span><span class="n">locator_txid_map</span><span class="p">))</span>

                <span class="n">triggered_flags</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">appointments_to_delete</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">uuid</span><span class="p">,</span> <span class="n">breach</span> <span class="ow">in</span> <span class="n">valid_breaches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="s2">&quot;Notifying responder and deleting appointment&quot;</span><span class="p">,</span>
                        <span class="n">penalty_txid</span><span class="o">=</span><span class="n">breach</span><span class="p">[</span><span class="s2">&quot;penalty_txid&quot;</span><span class="p">],</span>
                        <span class="n">locator</span><span class="o">=</span><span class="n">breach</span><span class="p">[</span><span class="s2">&quot;locator&quot;</span><span class="p">],</span>
                        <span class="n">uuid</span><span class="o">=</span><span class="n">uuid</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="n">receipt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">responder</span><span class="o">.</span><span class="n">handle_breach</span><span class="p">(</span>
                        <span class="n">uuid</span><span class="p">,</span>
                        <span class="n">breach</span><span class="p">[</span><span class="s2">&quot;locator&quot;</span><span class="p">],</span>
                        <span class="n">breach</span><span class="p">[</span><span class="s2">&quot;dispute_txid&quot;</span><span class="p">],</span>
                        <span class="n">breach</span><span class="p">[</span><span class="s2">&quot;penalty_txid&quot;</span><span class="p">],</span>
                        <span class="n">breach</span><span class="p">[</span><span class="s2">&quot;penalty_rawtx&quot;</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="p">[</span><span class="n">uuid</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;user_id&quot;</span><span class="p">),</span>
                        <span class="n">block_hash</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="c1"># FIXME: Only necessary because of the triggered appointment approach. Fix if it changes.</span>

                    <span class="k">if</span> <span class="n">receipt</span><span class="o">.</span><span class="n">delivered</span><span class="p">:</span>
                        <span class="n">Cleaner</span><span class="o">.</span><span class="n">delete_appointment_from_memory</span><span class="p">(</span><span class="n">uuid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator_uuid_map</span><span class="p">)</span>
                        <span class="n">triggered_flags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uuid</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">appointments_to_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uuid</span><span class="p">)</span>

                <span class="c1"># Appointments are only flagged as triggered if they are delivered, otherwise they are just deleted.</span>
                <span class="n">appointments_to_delete</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">invalid_breaches</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">batch_create_triggered_appointment_flag</span><span class="p">(</span><span class="n">triggered_flags</span><span class="p">)</span>

                <span class="c1"># Update the dictionary with the completed appointments</span>
                <span class="n">appointments_to_delete_gatekeeper</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">uuid</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="p">[</span><span class="n">uuid</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;user_id&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">uuid</span> <span class="ow">in</span> <span class="n">appointments_to_delete</span><span class="p">}</span>
                <span class="p">)</span>

                <span class="n">Cleaner</span><span class="o">.</span><span class="n">delete_completed_appointments</span><span class="p">(</span>
                    <span class="n">appointments_to_delete</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator_uuid_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span>
                <span class="p">)</span>

                <span class="c1"># Remove expired and completed appointments from the Gatekeeper</span>
                <span class="n">Cleaner</span><span class="o">.</span><span class="n">delete_gatekeeper_appointments</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gatekeeper</span><span class="p">,</span> <span class="n">appointments_to_delete_gatekeeper</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">appointments</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No more pending appointments&quot;</span><span class="p">)</span>

            <span class="c1"># Register the last processed block for the Watcher</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">store_last_block_hash_watcher</span><span class="p">(</span><span class="n">block_hash</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_known_block</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;hash&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span></div>

<div class="viewcode-block" id="Watcher.get_breaches"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher.get_breaches">[docs]</a>    <span class="k">def</span> <span class="nf">get_breaches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator_txid_map</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets a dictionary of channel breaches given a map of ``locator:dispute_txid``.</span>

<span class="sd">        Args:</span>
<span class="sd">            locator_txid_map (:obj:`dict`): the dictionary of locators (locator:txid) derived from a list of</span>
<span class="sd">                transaction ids.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`dict`: A dictionary (``locator:txid``) with all the breaches found. An empty dictionary if none are</span>
<span class="sd">            found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check is any of the tx_ids in the received block is an actual match</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locator_uuid_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">locator_txid_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">breaches</span> <span class="o">=</span> <span class="p">{</span><span class="n">locator</span><span class="p">:</span> <span class="n">locator_txid_map</span><span class="p">[</span><span class="n">locator</span><span class="p">]</span> <span class="k">for</span> <span class="n">locator</span> <span class="ow">in</span> <span class="n">intersection</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">breaches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;List of breaches&quot;</span><span class="p">,</span> <span class="n">breaches</span><span class="o">=</span><span class="n">breaches</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No breaches found&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">breaches</span></div>

<div class="viewcode-block" id="Watcher.check_breach"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher.check_breach">[docs]</a>    <span class="k">def</span> <span class="nf">check_breach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uuid</span><span class="p">,</span> <span class="n">appointment</span><span class="p">,</span> <span class="n">dispute_txid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a breach is valid. Valid breaches should decrypt to a valid transaction.</span>

<span class="sd">        Args:</span>
<span class="sd">            uuid (:obj:`str`): the uuid of the appointment that was triggered by the breach.</span>
<span class="sd">            appointment (:obj:`ExtendedAppointment &lt;teos.extended_appointment.ExtendedAppointment&gt;`): the appointment</span>
<span class="sd">                data.</span>
<span class="sd">            dispute_txid (:obj:`str`): the id of the transaction that triggered the breach.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`tuple`: A tuple containing the penalty txid and the raw penalty tx.</span>

<span class="sd">        Raises:</span>
<span class="sd">            :obj:`EncryptionError`: if the encrypted blob from the provided appointment cannot be decrypted with the</span>
<span class="sd">                key derived from the breach transaction id.</span>
<span class="sd">            :obj:`InvalidTransactionFormat`: if the decrypted data does not have a valid transaction format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">penalty_rawtx</span> <span class="o">=</span> <span class="n">Cryptographer</span><span class="o">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">appointment</span><span class="o">.</span><span class="n">encrypted_blob</span><span class="p">,</span> <span class="n">dispute_txid</span><span class="p">)</span>
            <span class="n">penalty_tx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_processor</span><span class="o">.</span><span class="n">decode_raw_transaction</span><span class="p">(</span><span class="n">penalty_rawtx</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">EncryptionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transaction cannot be decrypted&quot;</span><span class="p">,</span> <span class="n">uuid</span><span class="o">=</span><span class="n">uuid</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">e</span>

        <span class="k">except</span> <span class="n">InvalidTransactionFormat</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;The breach contained an invalid transaction&quot;</span><span class="p">,</span> <span class="n">uuid</span><span class="o">=</span><span class="n">uuid</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">e</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Breach found for locator&quot;</span><span class="p">,</span> <span class="n">locator</span><span class="o">=</span><span class="n">appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">,</span> <span class="n">uuid</span><span class="o">=</span><span class="n">uuid</span><span class="p">,</span> <span class="n">penalty_txid</span><span class="o">=</span><span class="n">penalty_tx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;txid&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">penalty_tx</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;txid&quot;</span><span class="p">),</span> <span class="n">penalty_rawtx</span></div>

<div class="viewcode-block" id="Watcher.filter_breaches"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher.filter_breaches">[docs]</a>    <span class="k">def</span> <span class="nf">filter_breaches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">breaches</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters the valid from the invalid channel breaches.</span>

<span class="sd">        The :obj:`Watcher` cannot know if an ``encrypted_blob`` contains a valid transaction until a breach is seen.</span>
<span class="sd">        Blobs that contain arbitrary data are dropped and not sent to the :obj:`Responder &lt;teos.responder.Responder&gt;`.</span>

<span class="sd">        Args:</span>
<span class="sd">            breaches (:obj:`dict`): a dictionary containing channel breaches (``locator:txid``).</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`tuple`: A dictionary and a list. The former contains the valid breaches, while the latter contain the</span>
<span class="sd">            invalid ones.</span>

<span class="sd">            The valid breaches dictionary has the following structure:</span>

<span class="sd">            ``{locator, dispute_txid, penalty_txid, penalty_rawtx}``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">valid_breaches</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">invalid_breaches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># A cache of the already decrypted blobs so replicate decryption can be avoided</span>
        <span class="n">decrypted_blobs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">locator</span><span class="p">,</span> <span class="n">dispute_txid</span> <span class="ow">in</span> <span class="n">breaches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">uuid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator_uuid_map</span><span class="p">[</span><span class="n">locator</span><span class="p">]:</span>
                <span class="n">appointment</span> <span class="o">=</span> <span class="n">ExtendedAppointment</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">load_watcher_appointment</span><span class="p">(</span><span class="n">uuid</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">appointment</span><span class="o">.</span><span class="n">encrypted_blob</span> <span class="ow">in</span> <span class="n">decrypted_blobs</span><span class="p">:</span>
                    <span class="n">penalty_txid</span><span class="p">,</span> <span class="n">penalty_rawtx</span> <span class="o">=</span> <span class="n">decrypted_blobs</span><span class="p">[</span><span class="n">appointment</span><span class="o">.</span><span class="n">encrypted_blob</span><span class="p">]</span>
                    <span class="n">valid_breaches</span><span class="p">[</span><span class="n">uuid</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;locator&quot;</span><span class="p">:</span> <span class="n">appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">,</span>
                        <span class="s2">&quot;dispute_txid&quot;</span><span class="p">:</span> <span class="n">dispute_txid</span><span class="p">,</span>
                        <span class="s2">&quot;penalty_txid&quot;</span><span class="p">:</span> <span class="n">penalty_txid</span><span class="p">,</span>
                        <span class="s2">&quot;penalty_rawtx&quot;</span><span class="p">:</span> <span class="n">penalty_rawtx</span><span class="p">,</span>
                    <span class="p">}</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">penalty_txid</span><span class="p">,</span> <span class="n">penalty_rawtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_breach</span><span class="p">(</span><span class="n">uuid</span><span class="p">,</span> <span class="n">appointment</span><span class="p">,</span> <span class="n">dispute_txid</span><span class="p">)</span>
                        <span class="n">valid_breaches</span><span class="p">[</span><span class="n">uuid</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s2">&quot;locator&quot;</span><span class="p">:</span> <span class="n">appointment</span><span class="o">.</span><span class="n">locator</span><span class="p">,</span>
                            <span class="s2">&quot;dispute_txid&quot;</span><span class="p">:</span> <span class="n">dispute_txid</span><span class="p">,</span>
                            <span class="s2">&quot;penalty_txid&quot;</span><span class="p">:</span> <span class="n">penalty_txid</span><span class="p">,</span>
                            <span class="s2">&quot;penalty_rawtx&quot;</span><span class="p">:</span> <span class="n">penalty_rawtx</span><span class="p">,</span>
                        <span class="p">}</span>
                        <span class="n">decrypted_blobs</span><span class="p">[</span><span class="n">appointment</span><span class="o">.</span><span class="n">encrypted_blob</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">penalty_txid</span><span class="p">,</span> <span class="n">penalty_rawtx</span><span class="p">)</span>

                    <span class="k">except</span> <span class="p">(</span><span class="n">EncryptionError</span><span class="p">,</span> <span class="n">InvalidTransactionFormat</span><span class="p">):</span>
                        <span class="n">invalid_breaches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uuid</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">valid_breaches</span><span class="p">,</span> <span class="n">invalid_breaches</span></div>

<div class="viewcode-block" id="Watcher.get_registered_user_ids"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher.get_registered_user_ids">[docs]</a>    <span class="k">def</span> <span class="nf">get_registered_user_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the list of user ids of all the registered users.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gatekeeper</span><span class="o">.</span><span class="n">registered_users</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="Watcher.get_user_info"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher.get_user_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_user_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the data hold by the tower about the user given an ``user_id``.</span>

<span class="sd">        Args:</span>
<span class="sd">            user_id (:obj:`str`): the id of the requested user.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj:`UserInfo &lt;teos.gatekeeper.UserInfo&gt; or :obj:`None`: The user data if found. :obj:`None` if not found, or</span>
<span class="sd">            the ``user_id`` is invalid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gatekeeper</span><span class="o">.</span><span class="n">registered_users</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="Watcher.get_all_watcher_appointments"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher.get_all_watcher_appointments">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_watcher_appointments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a dictionary with all the appointment stored in the db for the watcher.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">load_watcher_appointments</span><span class="p">()</span></div>

<div class="viewcode-block" id="Watcher.get_all_responder_trackers"><a class="viewcode-back" href="../../teos.watcher.html#teos.watcher.Watcher.get_all_responder_trackers">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_responder_trackers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a dictionary with all the trackers stored in the db for the responder.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_manager</span><span class="o">.</span><span class="n">load_responder_trackers</span><span class="p">()</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019, Talaia Labs

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>